---
import { words, filteredWords, currentFilter, searchTerm, currentPage, pageSize } from '../js/vocabulary/state.js';
import { saveWords, queryDictionary, getUniqueCategories } from '../js/vocabulary/utils.js';
import { updateWordsDisplay, renderCategoryFilters, updateCategoryFilterUI } from '../js/vocabulary/ui.js';

interface Word {
  id: string;
  word: string;
  pronunciation?: string;
  meaning: string;
  example?: string;
  category?: string;
  difficulty: 'easy' | 'medium' | 'hard';
  reviewCount: number;
}

// 状态管理函数
function setCurrentFilter(category: string) {
  // @ts-ignore
  currentFilter = category;
}

function setSearchTerm(term: string) {
  // @ts-ignore
  searchTerm = term;
}

function setCurrentPage(page: number) {
  // @ts-ignore
  currentPage = page;
}

// 核心功能
function addWord(newWordData: Omit<Word, 'id' | 'reviewCount'>) {
  const word: Word = {
    ...newWordData,
    id: Date.now().toString(),
    reviewCount: 0,
  };
  words.unshift(word);
  saveWords();
  applyFilters(currentFilter, searchTerm);
  renderCategoryFilters();
}

function deleteWord(id: string) {
  const index = words.findIndex(word => word.id === id);
  if (index > -1) {
    words.splice(index, 1);
    saveWords();
    applyFilters(currentFilter, searchTerm);
    renderCategoryFilters();
  }
}

function applyFilters(filterCategory: string, currentSearchTerm: string) {
  let result = [...words];

  if (currentSearchTerm?.trim()) {
    const term = currentSearchTerm.toLowerCase();
    result = result.filter(word => 
      word.word.toLowerCase().includes(term) ||
      word.meaning.toLowerCase().includes(term)
    );
  }

  if (filterCategory && filterCategory !== 'all') {
    result = result.filter(word => word.category === filterCategory);
  }

  filteredWords.length = 0;
  result.forEach(item => filteredWords.push(item));
  
  updateWordsDisplay();
  updateCategoryFilterUI(filterCategory);
}

// UI交互处理
function handleAddWordFormSubmit(event: SubmitEvent) {
  // @ts-ignore
  event.preventDefault();
  const form = event.target as HTMLFormElement;
  const formData = new FormData(form);
  
  const newWordData = {
    word: formData.get('word')?.toString().trim() || '',
    pronunciation: formData.get('pronunciation')?.toString().trim() || '',
    meaning: formData.get('meaning')?.toString().trim() || '',
    example: formData.get('example')?.toString().trim() || '',
    category: formData.get('category')?.toString().trim() || '',
    difficulty: formData.get('difficulty')?.toString() as 'easy' | 'medium' | 'hard' || 'medium',
  };

  if (!newWordData.word || !newWordData.meaning) {
    alert('单词和释义不能为空');
    return;
  }
  
  addWord(newWordData);
  form.reset();
}

function handleSearchInput(event: InputEvent) {
  const input = event.target as HTMLInputElement;
  setSearchTerm(input.value);
  applyFilters(currentFilter, input.value);
}

function handleCategoryFilterClick(category: string) {
  setCurrentFilter(category);
  applyFilters(category, searchTerm);
}

function handlePageChange(direction: 'prev' | 'next') {
  const totalPages = Math.ceil(filteredWords.length / pageSize);
  let newPage = currentPage;
  
  if (direction === 'prev' && currentPage > 1) {
    newPage = currentPage - 1;
  } else if (direction === 'next' && currentPage < totalPages) {
    newPage = currentPage + 1;
  }
  
  if (newPage !== currentPage) {
    setCurrentPage(newPage);
    updateWordsDisplay();
  }
}
---

<!-- 组件模板 -->
<div class="container mx-auto p-4">
  <!-- 搜索和过滤区域 -->
  <div class="mb-6">
    <input 
      id="search-input"
      type="text" 
      placeholder="搜索单词..." 
      class="w-full p-2 border rounded"
    />
    
    <div class="flex flex-wrap gap-2 mt-2" id="category-filters">
      <!-- 分类筛选按钮将通过renderCategoryFilters动态生成 -->
    </div>
  </div>
  
  <!-- 单词表格 -->
  <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
    <thead class="bg-gray-50 dark:bg-gray-800">
      <tr>
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">单词</th>
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">释义</th>
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">分类</th>
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">难度</th>
        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">操作</th>
      </tr>
    </thead>
    <tbody class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700" id="vocabulary-table">
      <!-- 单词内容将通过updateWordsDisplay动态生成 -->
    </tbody>
  </table>
  
  <!-- 分页控制 -->
  <div class="flex justify-between items-center mt-4">
    <button 
      id="prev-page-btn"
      class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded disabled:opacity-50"
      disabled={currentPage <= 1}
    >
      上一页
    </button>
    
    <span class="text-sm text-gray-600 dark:text-gray-400">
      共 {filteredWords.length} 个单词
    </span>
    
    <button 
      id="next-page-btn"
      class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded disabled:opacity-50"
      disabled={currentPage >= Math.ceil(filteredWords.length / pageSize)}
    >
      下一页
    </button>
  </div>
  
  <!-- 添加单词表单 -->
  <form id="add-word-form" class="mt-8 space-y-4">
    <h3 class="text-lg font-medium">添加新单词</h3>
    
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">单词</label>
        <input 
          type="text" 
          name="word" 
          required
          class="w-full p-2 border rounded"
        />
      </div>
      
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">发音</label>
        <input 
          type="text" 
          name="pronunciation" 
          class="w-full p-2 border rounded"
        />
      </div>
      
      <div class="md:col-span-2">
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">释义</label>
        <textarea 
          name="meaning" 
          required
          class="w-full p-2 border rounded"
          rows="2"
        ></textarea>
      </div>
      
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">例句</label>
        <input 
          type="text" 
          name="example" 
          class="w-full p-2 border rounded"
        />
      </div>
      
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">分类</label>
        <input 
          type="text" 
          name="category" 
          class="w-full p-2 border rounded"
        />
      </div>
      
      <div>
        <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">难度</label>
        <select 
          name="difficulty" 
          class="w-full p-2 border rounded"
        >
          <option value="easy">简单</option>
          <option value="medium" selected>中等</option>
          <option value="hard">困难</option>
        </select>
      </div>
    </div>
    
    <button 
      type="submit" 
      class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
    >
      添加单词
    </button>
  </form>
</div>

<script type="module">
  import { renderCategoryFilters, updateWordsDisplay } from '../js/vocabulary/ui.js';
  import { words, filteredWords, currentFilter, searchTerm, currentPage, pageSize } from '../js/vocabulary/state.js';
  import { saveWords } from '../js/vocabulary/utils.js';

  document.addEventListener('DOMContentLoaded', () => {
    // 初始化UI
    renderCategoryFilters();
    updateWordsDisplay();
    
    // 搜索输入处理
    const searchInput = document.getElementById('search-input');
    if (searchInput) {
      searchInput.addEventListener('input', (event) => {
        const input = event.target;
        searchTerm = input.value;
        applyFilters(currentFilter, input.value);
      });
    }
    
    // 分页按钮处理
    const prevPageBtn = document.getElementById('prev-page-btn');
    if (prevPageBtn) {
      prevPageBtn.addEventListener('click', () => {
        handlePageChange('prev');
      });
    }
    
    const nextPageBtn = document.getElementById('next-page-btn');
    if (nextPageBtn) {
      nextPageBtn.addEventListener('click', () => {
        handlePageChange('next');
      });
    }
    
    // 表单提交处理
    const addWordForm = document.getElementById('add-word-form');
    if (addWordForm) {
      addWordForm.addEventListener('submit', (event) => {
        event.preventDefault();
        const form = event.target;
        const formData = new FormData(form);
        
        const newWordData = {
          word: formData.get('word') ? formData.get('word').toString().trim() : '',
          pronunciation: formData.get('pronunciation') ? formData.get('pronunciation').toString().trim() : '',
          meaning: formData.get('meaning') ? formData.get('meaning').toString().trim() : '',
          example: formData.get('example') ? formData.get('example').toString().trim() : '',
          category: formData.get('category') ? formData.get('category').toString().trim() : '',
          difficulty: formData.get('difficulty') ? formData.get('difficulty').toString() : 'medium',
        };

        if (!newWordData.word || !newWordData.meaning) {
          alert('单词和释义不能为空');
          return;
        }
        
        const word = {
          ...newWordData,
          id: Date.now().toString(),
          reviewCount: 0,
        };
        
        words.unshift(word);
        saveWords();
        applyFilters(currentFilter, searchTerm);
        renderCategoryFilters();
        
        form.reset();
      });
    }
    
    // 分类筛选处理
    document.addEventListener('click', (event) => {
      const target = event.target;
      if (target.classList && target.classList.contains('category-filter')) {
        const category = target.dataset.category || '';
        currentFilter = category;
        applyFilters(category, searchTerm);
      }
    });
  });
  
  function applyFilters(filterCategory, currentSearchTerm) {
    let result = [...words];

    if (currentSearchTerm && currentSearchTerm.trim()) {
      const term = currentSearchTerm.toLowerCase();
      result = result.filter(word => 
        word.word.toLowerCase().includes(term) ||
        word.meaning.toLowerCase().includes(term)
      );
    }

    if (filterCategory && filterCategory !== 'all') {
      result = result.filter(word => word.category === filterCategory);
    }

    filteredWords.length = 0;
    result.forEach(item => filteredWords.push(item));
    
    updateWordsDisplay();
    updateCategoryFilterUI(filterCategory);
  }
  
  function handlePageChange(direction) {
    const totalPages = Math.ceil(filteredWords.length / pageSize);
    let newPage = currentPage;
    
    if (direction === 'prev' && currentPage > 1) {
      newPage = currentPage - 1;
    } else if (direction === 'next' && currentPage < totalPages) {
      newPage = currentPage + 1;
    }
    
    if (newPage !== currentPage) {
      currentPage = newPage;
      updateWordsDisplay();
    }
  }
  
  function updateCategoryFilterUI(filterCategory) {
    const filters = document.querySelectorAll('.category-filter');
    filters.forEach(filter => {
      const element = filter;
      const category = element.dataset.category || '';
      
      if (category === filterCategory) {
        element.classList.add('bg-blue-500', 'text-white');
        element.classList.remove('bg-gray-200', 'dark:bg-gray-700');
      } else {
        element.classList.remove('bg-blue-500', 'text-white');
        element.classList.add('bg-gray-200', 'dark:bg-gray-700');
      }
    });
  }
</script>